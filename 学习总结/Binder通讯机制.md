# Binder通讯机制

## 一、Binder概述

#### 1.简介

- 从通讯层面看，Binder是一种通讯机制
- 从驱动层面看，Binder是一个虚拟物理设备驱动
- 从应用层看：Binder是一个封装好的Bean类

#### 2.作用

binder是android中的“血管”，Android系统中，各大服务进程(system_server)与用户进程间的通讯，AIDL以及许多跨进程通讯都是由借助Binder来实现的。

#### 3.常见的跨进程通讯方式和Binder的区别

###### 3.1 Android常见的跨进程通讯方式有以下几种

- 管道
- 消息队列
- Socket
- 文件
- Binder
- 共享内存

###### 3.2 而它们在进行一次通讯的时候拷贝的次数分别为：

- 管道：2次
- 消息队列：2次
- Socket：2次
- 文件：2次
- Binder：1次
- 共享内存：0次

###### 3.3 Binder相比较管道、消息队列、Socket、文件这些传统的进程间通讯方式，可以体现出以下这些优势

| 优势   | 描述                                                |
| ------ | --------------------------------------------------- |
| 性能   | 只需要一次数据拷贝，性能上仅次于共享内存            |
| 稳定性 | 基于C/S架构，职责明确，架构清晰                     |
| 安全性 | 为每个App分配UID，进程的UID是鉴别进程身份的重要标志 |

###### 3.3 Binder于共享内存

Binder性能次于共享内存，但是多个进程操作共享内存就会有同步和资源竞争的问题，从安全的角度上看，使用Binder更加具有优势。

###### 3.5 在安全方面

- 传统的进程间通讯方式对于通讯双方并没有做严格的身份验证机制，比如Socket通讯的IP地址是客户端手动输入，很容易伪造，而Binder通讯中的App UID由Binder分配，非用户手动输入，无法伪造。
- Binder机制从协议本身(RPC协议)就支持对通讯双方做身份验证，从而大大提升了安全性

###### 3.6 补充：拷贝的概念

- 在Linux系统中，通讯的本质就是数据的拷贝

- ##### 数据拷贝是指：数据从用户空间复制到内核空间，或者是从内核空间复制到用户空间，所以每一次数据拷贝都会涉及到 用户态->内核态 的切换

###### 3.7 进程的内核地址与私有地址

##### 每个进程都有自己的一段虚拟地址，

- 这个虚拟地址中有最开始的一段地址属于内核地址，这段地址是进程之间共享的
- 其余的地址为用户地址，这段地址是私有的
- 用户进程想要访问内核地址，必须要从用户态切换到内核态
- 以下图为例，32位的主机会为每一个进程分配4GB的虚拟内存空间，
  - **内核地址：**在这4GB的虚拟内存空间当中，起始的1GB空间是内核地址，所有进程的内核地址都会映射到同一块物理地址(内核物理地址，也就是内核在内存的位置)。所有现场都可以访问内核地址，但是需要从用户态切换到内核态，会有一定的性能开销。
  - **私有地址：**而其余的3GB是进程私有地址，不同进程的私有地址一般来说互不影响，用户可以手动为进程开辟**共享内存**，使得进程A的某一段虚拟地址和进程B的某一段虚拟地址映射到同一个物理内存(mmap)。不同进程间除了共享内存之外的私有地址所映射的物理内存为线程私有，别的进程无法访问，这就实现了进程之间数据的隔离保证了进程间数据的安全性。

![image-20221019193213174](Binder%E9%80%9A%E8%AE%AF%E6%9C%BA%E5%88%B6.assets/image-20221019193213174.png)