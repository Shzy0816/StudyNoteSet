GC与调优

### Java自动化内存管理

- 好处：无需开发人员手动进行内存分配与回收，降低内存泄漏与溢出风险
- 缺点：弱化了开发人员在程序出现内存溢出时定位问题和解决问题的能力
- 对于我们现在的意义：我们必须对这些自动化技术的原理进行了解，学会如何去监控和调节



### GC

##### 1.面试题：什么是垃圾？

可以这么回答：没有被GC root对象们直接或者间接引用的
也可以这么答：在程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾



##### 2.内存碎片的概念：

在内存分配和回收过程中产生的不连续的空闲内存空间



##### 3.GC的作用？

- 对于系统而言，内存迟早都会消耗完，GC能够即使地回收垃圾对象从而释放内存空间
- 整理内存碎片



### 垃圾回收相关算法

##### 1.垃圾回收算法概述

垃圾的回收应该包括两部分：一是确认垃圾对象，二是清楚垃圾对象。这两部分也都会对应相应的算法

垃圾确认算法 -- 标记阶段算法

- 引用计数算法
- GC Root可达性分析算法

清除垃圾算法 -- 清除阶段算法

- 标记-清除算法 (这里的标记其实指的就是确认垃圾)
- 复制算法
- 标记-压缩算法



##### 2.引用计数算法

- 原理：对每一个对象保存一个整形的引用计数属性，用于记录对象被引用的次数。

  例子：对于对象A，只要有任何一个对象引用了对象A，对象A的引用计数器就+1，引用失效时-1。当对象A引用计数器的值为0时，表示对象A不会再被使用，需要进行回收

- 优点：实现简单，垃圾对象易于识别，判断效率高

- 缺点：无法处理循环引用的情况

  循环引用例子：对象A持有对象B，对象B持有对象A，当这两个对象不再被GC Root使用的时候，它们的计数器会一直是1，永远无法得到释放



##### 3.可达性分析算法

- 相对于引用计数器，他有效解决了在引用计数算法中的循环引用问题，防止内存泄漏的发生，这种类型的垃圾收集也叫追踪性垃圾收集
- 概念：可达性分析算法以根对象(GC Root对象)集合为起点，按照从上到下的方式搜索被跟

